"""
Strategy Validator Module

This module provides functionality to validate trading strategies by comparing
signals generated by SQL-based historical strategies with executable real-time
strategy classes.

Author: Trading System QA
Date: 2025-09-02
"""

import sqlite3
from typing import Type, Any, Dict, List, Optional
import pandas as pd
import numpy as np
from datetime import datetime
import logging
from abc import ABC, abstractmethod


# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class BaseExecutableStrategy(ABC):
    """
    Abstract base class for executable strategies.
    All executable strategies should inherit from this class.
    """
    
    def __init__(self):
        """Initialize the strategy with empty state."""
        self.signals: List[Dict[str, Any]] = []
    
    @abstractmethod
    def process_candle(self, candle: pd.Series) -> Optional[int]:
        """
        Process a single candle and return a signal.
        
        Args:
            candle: A pandas Series representing a single OHLCV candle
                   with columns: timestamp, open, high, low, close, volume
        
        Returns:
            Signal value (typically -1, 0, or 1) or None if no signal
        """
        pass
    
    def reset(self):
        """Reset the strategy state."""
        self.signals = []


class StrategyValidator:
    """
    A class for validating trading strategies by comparing SQL-based historical
    strategies with executable real-time strategy implementations.
    
    This validator ensures that both approaches generate identical signals
    for the same input data, which is crucial for maintaining consistency
    between backtesting and live trading.
    
    Attributes:
        db_path (str): Path to the SQLite database containing OHLCV data
        connection (sqlite3.Connection): Database connection object
    """
    
    def __init__(self, db_path: str):
        """
        Initialize the StrategyValidator with a database path.
        
        Args:
            db_path: Path to the SQLite database containing OHLCV data
        
        Raises:
            sqlite3.Error: If database connection fails
        """
        self.db_path = db_path
        try:
            self.connection = sqlite3.connect(db_path)
            logger.info(f"Connected to database: {db_path}")
        except sqlite3.Error as e:
            logger.error(f"Failed to connect to database: {e}")
            raise
    
    def __del__(self):
        """Close database connection on object destruction."""
        if hasattr(self, 'connection'):
            self.connection.close()
    
    def _fetch_ohlcv_data(self, symbol: str, timeframe: str, 
                          start_date: str, end_date: str) -> pd.DataFrame:
        """
        Fetch OHLCV data from the database for the specified parameters.
        
        Args:
            symbol: Trading symbol (e.g., 'BTCUSDT')
            timeframe: Timeframe (e.g., '1h', '4h', '1d')
            start_date: Start date in 'YYYY-MM-DD' format
            end_date: End date in 'YYYY-MM-DD' format
        
        Returns:
            DataFrame with columns: timestamp, open, high, low, close, volume
        
        Raises:
            ValueError: If no data found for the specified parameters
        """
        query = """
        SELECT timestamp, open, high, low, close, volume
        FROM ohlcv
        WHERE symbol = ? AND timeframe = ? 
        AND timestamp >= ? AND timestamp <= ?
        ORDER BY timestamp ASC
        """
        
        try:
            df = pd.read_sql_query(
                query, 
                self.connection,
                params=(symbol, timeframe, start_date, end_date)
            )
            
            if df.empty:
                raise ValueError(
                    f"No OHLCV data found for {symbol} {timeframe} "
                    f"between {start_date} and {end_date}"
                )
            
            # Ensure timestamp is datetime
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            logger.info(
                f"Fetched {len(df)} candles for {symbol} {timeframe} "
                f"from {start_date} to {end_date}"
            )
            
            return df
            
        except sqlite3.Error as e:
            logger.error(f"Database query error: {e}")
            raise
    
    def _execute_sql_strategy(self, sql_query: str) -> pd.DataFrame:
        """
        Execute the SQL strategy query and return the results.
        
        Args:
            sql_query: SQL query that returns timestamp and signal columns
        
        Returns:
            DataFrame with columns: timestamp, signal
        
        Raises:
            ValueError: If query doesn't return required columns
        """
        try:
            df = pd.read_sql_query(sql_query, self.connection)
            
            # Validate required columns
            required_columns = {'timestamp', 'signal'}
            if not required_columns.issubset(df.columns):
                missing = required_columns - set(df.columns)
                raise ValueError(
                    f"SQL query must return columns: {required_columns}. "
                    f"Missing: {missing}"
                )
            
            # Ensure timestamp is datetime
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            # Keep only required columns and sort by timestamp
            df = df[['timestamp', 'signal']].sort_values('timestamp')
            
            logger.info(f"SQL strategy returned {len(df)} signals")
            
            return df
            
        except sqlite3.Error as e:
            logger.error(f"SQL strategy execution error: {e}")
            raise
    
    def _run_executable_strategy(self, strategy_class: Type[BaseExecutableStrategy],
                               ohlcv_data: pd.DataFrame) -> pd.DataFrame:
        """
        Run the executable strategy on the OHLCV data row by row.
        
        Args:
            strategy_class: Class type that inherits from BaseExecutableStrategy
            ohlcv_data: DataFrame with OHLCV data
        
        Returns:
            DataFrame with columns: timestamp, signal
        
        Raises:
            TypeError: If strategy_class doesn't inherit from BaseExecutableStrategy
        """
        # Validate strategy class
        if not issubclass(strategy_class, BaseExecutableStrategy):
            raise TypeError(
                f"{strategy_class.__name__} must inherit from BaseExecutableStrategy"
            )
        
        # Instantiate strategy
        strategy = strategy_class()
        strategy.reset()
        
        results = []
        
        # Process each candle sequentially (simulating live data flow)
        for idx, candle in ohlcv_data.iterrows():
            try:
                signal = strategy.process_candle(candle)
                
                # Store result even if signal is None (converted to 0)
                results.append({
                    'timestamp': candle['timestamp'],
                    'signal': signal if signal is not None else 0
                })
                
            except Exception as e:
                logger.error(
                    f"Error processing candle at {candle['timestamp']}: {e}"
                )
                # Continue processing but record as no signal
                results.append({
                    'timestamp': candle['timestamp'],
                    'signal': 0
                })
        
        df = pd.DataFrame(results)
        logger.info(f"Executable strategy generated {len(df)} signals")
        
        return df
    
    def compare_strategies(self, sql_query: str, executable_strategy_class: Type[BaseExecutableStrategy],
                         symbol: str, timeframe: str, start_date: str, end_date: str) -> pd.DataFrame:
        """
        Compare signals generated by SQL and executable strategies.
        
        This method:
        1. Fetches OHLCV data for the specified parameters
        2. Executes the SQL strategy query to get historical signals
        3. Runs the executable strategy on the same data
        4. Compares the signals and returns a detailed comparison
        
        Args:
            sql_query: SQL query that returns timestamp and signal columns
            executable_strategy_class: Class type inheriting from BaseExecutableStrategy
            symbol: Trading symbol (e.g., 'BTCUSDT')
            timeframe: Timeframe (e.g., '1h', '4h', '1d')
            start_date: Start date in 'YYYY-MM-DD' format
            end_date: End date in 'YYYY-MM-DD' format
        
        Returns:
            DataFrame with columns:
            - timestamp: Timestamp of the candle
            - sql_signal: Signal from SQL strategy
            - executable_signal: Signal from executable strategy
            - signals_match: Boolean indicating if signals match
            - difference: Numerical difference between signals
        
        Example:
            validator = StrategyValidator('trading.db')
            comparison = validator.compare_strategies(
                sql_query="SELECT timestamp, signal FROM strategy_signals WHERE ...",
                executable_strategy_class=MyStrategy,
                symbol='BTCUSDT',
                timeframe='1h',
                start_date='2024-01-01',
                end_date='2024-01-31'
            )
        """
        logger.info(
            f"Starting strategy comparison for {symbol} {timeframe} "
            f"from {start_date} to {end_date}"
        )
        
        try:
            # Step 1: Fetch OHLCV data
            ohlcv_data = self._fetch_ohlcv_data(symbol, timeframe, start_date, end_date)
            
            # Step 2: Execute SQL strategy
            sql_signals = self._execute_sql_strategy(sql_query)
            
            # Step 3: Run executable strategy
            executable_signals = self._run_executable_strategy(
                executable_strategy_class, ohlcv_data
            )
            
            # Step 4: Merge and compare results
            comparison = pd.merge(
                sql_signals,
                executable_signals,
                on='timestamp',
                how='outer',
                suffixes=('_sql', '_executable')
            )
            
            # Rename columns for clarity
            comparison = comparison.rename(columns={
                'signal_sql': 'sql_signal',
                'signal_executable': 'executable_signal'
            })
            
            # Fill NaN values with 0 (no signal)
            comparison['sql_signal'] = comparison['sql_signal'].fillna(0)
            comparison['executable_signal'] = comparison['executable_signal'].fillna(0)
            
            # Add comparison columns
            comparison['signals_match'] = (
                comparison['sql_signal'] == comparison['executable_signal']
            )
            comparison['difference'] = (
                comparison['sql_signal'] - comparison['executable_signal']
            )
            
            # Sort by timestamp
            comparison = comparison.sort_values('timestamp').reset_index(drop=True)
            
            # Log summary statistics
            total_comparisons = len(comparison)
            matches = comparison['signals_match'].sum()
            match_rate = (matches / total_comparisons * 100) if total_comparisons > 0 else 0
            
            logger.info(
                f"Comparison complete: {matches}/{total_comparisons} signals match "
                f"({match_rate:.2f}% match rate)"
            )
            
            if not comparison['signals_match'].all():
                mismatches = comparison[~comparison['signals_match']]
                logger.warning(
                    f"Found {len(mismatches)} signal mismatches. "
                    f"First mismatch at {mismatches.iloc[0]['timestamp']}"
                )
            
            return comparison
            
        except Exception as e:
            logger.error(f"Strategy comparison failed: {e}")
            raise


# Example usage and testing
if __name__ == "__main__":
    # Example executable strategy implementation
    class ExampleStrategy(BaseExecutableStrategy):
        """
        Example strategy that generates buy/sell signals based on simple rules.
        """
        
        def __init__(self):
            super().__init__()
            self.previous_close = None
        
        def process_candle(self, candle: pd.Series) -> Optional[int]:
            """
            Generate signal based on price movement.
            Buy (1) if price increased by more than 2%
            Sell (-1) if price decreased by more than 2%
            Hold (0) otherwise
            """
            if self.previous_close is None:
                self.previous_close = candle['close']
                return 0
            
            price_change = (candle['close'] - self.previous_close) / self.previous_close
            
            signal = 0
            if price_change > 0.02:  # 2% increase
                signal = 1
            elif price_change < -0.02:  # 2% decrease
                signal = -1
            
            self.previous_close = candle['close']
            return signal
    
    # Example usage
    try:
        # Initialize validator
        validator = StrategyValidator('trading.db')
        
        # Define SQL query for historical signals
        sql_query = """
        SELECT 
            timestamp,
            CASE 
                WHEN price_change > 0.02 THEN 1
                WHEN price_change < -0.02 THEN -1
                ELSE 0
            END as signal
        FROM (
            SELECT 
                timestamp,
                close,
                (close - LAG(close) OVER (ORDER BY timestamp)) / LAG(close) OVER (ORDER BY timestamp) as price_change
            FROM ohlcv
            WHERE symbol = 'BTCUSDT' AND timeframe = '1h'
            AND timestamp >= '2024-01-01' AND timestamp <= '2024-01-31'
        ) t
        WHERE price_change IS NOT NULL
        """
        
        # Compare strategies
        comparison_df = validator.compare_strategies(
            sql_query=sql_query,
            executable_strategy_class=ExampleStrategy,
            symbol='BTCUSDT',
            timeframe='1h',
            start_date='2024-01-01',
            end_date='2024-01-31'
        )
        
        # Display results
        print("\nStrategy Comparison Results:")
        print(comparison_df.head(10))
        
        # Show summary
        print(f"\nTotal signals compared: {len(comparison_df)}")
        print(f"Matching signals: {comparison_df['signals_match'].sum()}")
        print(f"Mismatched signals: {(~comparison_df['signals_match']).sum()}")
        
        # Show mismatches if any
        if not comparison_df['signals_match'].all():
            print("\nFirst 5 mismatches:")
            print(comparison_df[~comparison_df['signals_match']].head())
            
    except Exception as e:
        print(f"Error: {e}")
